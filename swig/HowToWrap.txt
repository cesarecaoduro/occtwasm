// Created: 2007-06-29
//
// Copyright (c) 2007-2021 OPEN CASCADE SAS
//
// This file is part of commercial software by OPEN CASCADE SAS.
//
// This software is furnished in accordance with the terms and conditions
// of the contract and with the inclusion of this copyright notice.
// This software or any other copy thereof may not be provided or otherwise
// be made available to any third party.
//
// No ownership title to the software is transferred hereby.
//
// OPEN CASCADE SAS makes no representation or warranties with respect to the
// performance of this software, and specifically disclaims any responsibility
// for any damages, special or consequential, connected with its use.

Wrapping OCCT classes to C# and Java
====================================

This directory contains common SWIG interface files for wrapping OCCT to C# and
Java, defining a set of OCCT classes being wrapped. 

See folders csharp and java for language-specific SWIG definitions and relevant
tools and projects.

Adding new classes
------------------

The following are the typical steps necessary for adding new classes to
wrapped interface. These steps are applied to each class or other type 
(e.g. enumeration) being added.

a) Locate package and toolkit that the class belongs to.

   Note that normally package name constitutes first part of name of the 
   class or enum (before underscore or dot); the toolkit that the package
   belongs to can be found by searching files PACKAGE in OCCT source
   (directories %CASROOT%\src\TK*).

b) Find SWIG interface file for relevant toolkit.

c) If SWIG interface file for a toolkit is not yet present, create it by 
   copying file TKHLR.i and replacing "TKHLR" with name of your toolkit.

   Then add %include instruction for it (and its ancestors) to the main 
   (language specific) interface file located in the sample 
   (occcsharp.i for C# and occjava.i for Java). 
   
   The order of inclusion of interface files should correspond to order of 
   dependency between toolkits. Consult OCCT reference documentation 
   (http://dev.opencascade.org/doc/refman) as needed.

d) Add wrapping instruction for the new class into toolkit interface file.
   The wrapping instructions for the classes should be ordered according to
   dependencies between classes (if class A uses class B as base class or in
   arguments of its public methods, then class B should be wrapped first).

   Wrapping instructions have the form of the SWIG macros with name of the 
   class or enum being wrapped as argument:

   - WRAP_INCLUDE(name):            parses header of the specified class,
                                    can be used for wrapping simple typedefs.
   - WRAP_AS_VOID_PTR(name):        used to wrap typedefs to void*.
   - WRAP_AS_ENUM_INCLUDE(name):    used to wrap an enumeration. 
   - WRAP_AS_HANDLE_INCLUDE(class): used to wrap a class inheriting Transient.

   - WRAP_AS_CLASS_INCLUDE(name):   used to wrap a non-handle class 
                                    not intended to be copied by value 
                                    (e.g. non-copyable). 
   - WRAP_AS_STRUCT_INCLUDE(name):  used to wrap a non-handle class 
                                    normally copied by value
                                    (must have copy constructor). 

   To decide between WRAP_AS_STRUCT and WRAP_AS_CLASS, the simple rule of 
   thumb can be used:
     
   - If C++ class does not have a public copy constructor, wrap it with 
     WRAP_AS_CLASS_INCLUDE
   - Otherwise, wrap it with WRAP_AS_STRUCT_INCLUDE

   Note that if a class does not have a public copy constructor, then the 
   wrapper code generated for it by WRAP_AS_STRUCT_INCLUDE will trigger a 
   compiler error in C# wrapper.

   Here is an example of the error shown by MS Visual C++ 8.0 compiler on 
   the attempt to wrap class Quantity_Array1OfColor using this macro:

   1>.\occcsharp_wrap.cxx(830) : error C2248: 'Quantity_Array1OfColor::Quantity_Array1OfColor' : 
   cannot access private member declared in class 'Quantity_Array1OfColor'

   This means that it is safe to first try using WRAP_AS_STRUCT_INCLUDE for 
   newly wrapped classes, and turn to using WRAP_AS_CLASS_INCLUDE if this 
   kind of error appears.

   Analyzing header files to figure out if a class has a public copy 
   constructor or not is also possible but more complicated.

   Note that the only difference between these two macros is how the situation 
   of returning a reference  to a C++ object is handled on C# level. For 
   classes wrapped using WRAP_AS_STRUCT_INCLUDE it will be necessary to cast 
   the result to a relevant C# wrapper object specifying explicitly whether
   this wrapper will contain a reference to the same C++ object (method 
   AsReference()) or copy of the object (method AsCopy()).

   See an example of this use in method Test.TestReference() in the library 
   CSharpTest of the C# wrapper sample.

   Special macros are provided for wrapping instantiations of templates 
   and in particular collection classes from NCollection package. 

   - WRAP_AS_TEMPLATE_INCLUDE(class,definition):
     for wrapping simple templates (without nested classes).
   - WRAP_AS_NCOLLECTION_INCLUDE(class,collection,type): 
     for simple collections with iterator (list, array, sequence etc.).
   - WRAP_AS_MAP_INCLUDE(class,collection,type,hasher): 
     for hash maps.
   - WRAP_AS_DATAMAP_INCLUDE(class,collection,typekey,typevalue,hasher):
     for data maps.

   These macros assume that typedef ("class" in the above macros) for given
   instantiation of the template collection is defined in the file class.hxx.
   The wrapper class will have the same name. Note that each class can be 
   wrapped only once, thus if you have several typedefs of the same template
   class in C++, only one of them should be wrapped. 

   The last three macros add special definitions for nested Iterator class of
   the collection, wrapped to class with the name of the main class with
   additional suffix "_Iterator".

   Note that NCollection wrapped into C# language implements IEnumerable interface,
   so that class instance can be passed directly into foreach statement in addition
   to usage of dedicated Iterator class.

   Also OCC exception hierarchy is being wrapped (currently done only for Java,
   derived from RuntimeException). Exception handling logic can be found in
   occjava.i that is catching OCC exceptions and replacing them with a
   corresponding wrapped exception class or a default RuntimeException if there's
   no such class. Such exceptions can be caught later in java code with a
   matching catch statement.
   To wrap new exception classes WRAP_AS_EXCEPTION(name) macro should be used.
   An example of exception handling can be found in method Test.TestErrorHandling()
   of Java wrapper sample Test.   

   Use SWIG instructions to customize wrappers. Some useful instructions are:

   - to ignore method that is not useful or cannot be correctly wrapped:
     %ignore class::method;

   - to enable possibility to inherit wrapped class and redefine virtual 
     methods in target language (C# or Java):
     %feature("director") class;

   - implement Object.ToString() method when wrapping class into C# language,
     which would improve diagnostic when using Debugger;
       %typemap(cscode) gp_XYZ %{
         public override string ToString() { return X() + " " + Y() + " " + Z(); }
       %}
     beware that multiple typemap(cscode) for the same class are not aggregated by SWIG,
     the latest definition overrides previous ones;

   - wrap get/set methods into C# properties to see them from Debugger:
       WRAP_PROPERTY(gp_XYZ, double, x, X, SetX);
     or
       %attribute(gp_XYZ, double, x, X, SetX);
     with the latter one automatically excluding get/set methods from wrapping
     preserving access only as property; WRAP_PROPERTY is analog of %attribute
     just introducing property without hiding methods.

   - wrap methods returning non-constant references (e.g. to access class fields
     by reference) for C#:
       %attributeref(class, returning_type, method);
     This should be used before class wrapping macro. Example of this can be found
     in TKDESTL.i for a StlAPI_Writer's method ASCIIMode and it's usage in ExportStl
     method of OCCWinForms_Viewer.

   See more examples in the wrapper.

e) Re-generate wrappers and sample (see sample documentation) 

f) In case of problems consult sample description and SWIG documentation

Wrapping hints
--------------

The classes shall be wrapped in the order of their dependance; if there is a 
cyclic dependence between classes, split the wrapping instructions by using 
low-level wrapping macros (see how class V3d_View is wrapped for example).

To facilitate including all classes in correct order, interface files are 
organized into the hierarchy corresponding to modular structure 
of OCCT, i.e. by module - toolkit - package. The top-level interface file
(language specific, e.g. occcsharp.i for C#) %includes interface files for 
toolkits in the order of their appearance in modules; then each toolkit wraps 
classes sorted by packages. 

The most difficult thing is to identify a closed set of classes to be wrapped,
i.e. to make sure that all the types used in wrapped interface of the class are 
also appropriately wrapped, so that they can be actually used in the target 
language.

Usually, when you wrap a new class, it happens that it uses some other classes 
not yet wrapped. This can be noticed by appearance of incomplete shadow classes 
with names like SWIGTYPE_p*.cs. SWIG generates these classes to wrap types that 
it does not know, so that these types still can be operated with (for 
return types and passing as arguments).

Note that sample contains a script listbad.bat which outputs a list of 
incomplete shadow classes generated, with indication of classes that refer to 
each.

The typical ways to eliminate such incomplete shadow classes are:

- If this type is required/useful, wrap it

- If this type is already wrapped, check for it being used by other classes, 
  wrapped before it.

  The most easy way to do that is to search shadow classes for using this 
  SWIGTYPE_p* type. In case of cyclic dependence, usually it is sufficient to 
  split wrapping macros for one of them in two: first to declare necessary 
  typemaps (e.g. WRAP_AS_HANDLE) before other related classes, and then 
  WRAP_INCLUDE to include definition of the class after all of them. 

- If this type is not useful in the target language, add %ignore statement for 
  all methods that use it (this is especially suitable when such methods are 
  only a few :-)

- Well, if nothing helps, or you do not want to bother, just keep incomplete 
  shadow classes as they are

Note that it is advisable to delete all shadow classes from time to time and 
regenerate anew, when interface definitions change, in order to avoid keeping 
obsolete and unneeded ones (especially incomplete shadow classes).

The script makewrapper.bat in the sample does all the job to regenerate 
wrappers and update projects. 
