import { resolve, dirname, join } from 'node:path';
import { mkdirSync, writeFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { loadModulesConfig, loadMinimalConfig, type ModuleConfig } from './parse-config.js';
import { emitEmbindModule } from './emit-embind.js';
import { emitTypeScriptWrappers, emitModuleTypes } from './emit-typescript.js';
import { registerEnums, registerClasses } from './type-mapper.js';
import { mergeHeadersAndConfig } from './merge-config.js';

// ---------------------------------------------------------------------------
// Path constants
// ---------------------------------------------------------------------------

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, '../..');
const CONFIG_DIR = resolve(__dirname, '../config');
const HEADER_DIR = resolve(ROOT, 'build/occt-install/include/opencascade');
const CPP_OUT = resolve(ROOT, 'bindings/generated/cpp');
const TS_OUT = resolve(ROOT, 'bindings/generated/ts');

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function main(): void {
  mkdirSync(CPP_OUT, { recursive: true });
  mkdirSync(TS_OUT, { recursive: true });

  const modulesConfig = loadModulesConfig(CONFIG_DIR);

  // First pass: merge configs and register all types across modules.
  // This builds the classToModule map needed for cross-module TS imports.
  const moduleConfigs: { moduleName: string; config: ModuleConfig }[] = [];
  const classToModule = new Map<string, string>();

  for (const [moduleName, moduleEntry] of Object.entries(modulesConfig.modules)) {
    if (!moduleEntry.enabled) {
      console.log(`Skipping disabled module: ${moduleName}`);
      continue;
    }

    console.log(`Processing module: ${moduleName}`);

    const minimalConfig = loadMinimalConfig(CONFIG_DIR, moduleEntry.config);
    const result = mergeHeadersAndConfig(minimalConfig, HEADER_DIR);

    for (const w of result.warnings) {
      const prefix = w.level === 'error' ? 'ERROR' : 'WARN';
      console.log(`  [${prefix}] ${w.message}`);
    }

    const config = result.config;
    registerClasses(Object.keys(config.classes));
    registerEnums(Object.keys(config.enums));

    for (const className of Object.keys(config.classes)) {
      classToModule.set(className, moduleName);
    }

    moduleConfigs.push({ moduleName, config });
  }

  // Second pass: emit code with full cross-module type info
  // Also collect module interface types across all modules.
  const allHandles: string[] = [];
  const allConstructors: string[] = [];
  const allEnums: string[] = [];
  const allProperties: string[] = [];

  for (const { moduleName, config } of moduleConfigs) {
    const cppContent = emitEmbindModule(config);
    const cppPath = join(CPP_OUT, `${moduleName}.cpp`);
    writeFileSync(cppPath, cppContent, 'utf-8');
    console.log(`  Written: ${cppPath}`);

    const tsContent = emitTypeScriptWrappers(config, classToModule);
    const tsPath = join(TS_OUT, `${moduleName}.ts`);
    writeFileSync(tsPath, tsContent, 'utf-8');
    console.log(`  Written: ${tsPath}`);

    // Collect module interface types
    const modTypes = emitModuleTypes(config);
    allHandles.push(...modTypes.handles);
    allConstructors.push(...modTypes.constructors);
    allEnums.push(...modTypes.enums);
    allProperties.push(...modTypes.properties);
  }

  // Emit aggregated module interface types
  const moduleTypesContent = [
    '// This file is auto-generated by codegen. Do not edit.',
    '',
    '/** Raw embind handle interfaces â€” the objects returned by Module constructors. */',
    'export declare namespace EmbindHandles {',
    allHandles.join('\n\n'),
    '}',
    '',
    '/** Constructor interfaces for each embind-registered class. */',
    'export declare namespace EmbindConstructors {',
    allConstructors.join('\n\n'),
    '}',
    '',
    '/** Enum interfaces for each embind-registered enum. */',
    'export declare namespace EmbindEnums {',
    allEnums.join('\n\n'),
    '}',
    '',
    '/** Generated portion of the OcctModule interface. */',
    'export interface GeneratedOcctModule {',
    allProperties.join('\n'),
    '}',
    '',
  ].join('\n');

  const moduleTypesPath = join(TS_OUT, 'module-types.ts');
  writeFileSync(moduleTypesPath, moduleTypesContent, 'utf-8');
  console.log(`  Written: ${moduleTypesPath}`);

  console.log('Codegen complete.');
}

main();
