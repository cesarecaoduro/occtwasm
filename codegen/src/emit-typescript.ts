import type {
  ModuleConfig,
  ClassDef,
  MethodDef,
  MethodOverload,
  ConstructorDef,
  EnumDef,
  Arg,
} from './parse-config.js';
import { isOverloaded, getOverloads, getReturnType } from './parse-config.js';
import { cppToTsType, isOcctClass, isOcctEnum, isPrimitive, tsTypeForArg } from './type-mapper.js';
import {
  generateInstanceofCheck,
  generateOverloadDispatch,
} from './overload-resolver.js';

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const FILE_HEADER = `// This file is auto-generated by codegen. Do not edit.
// @ts-nocheck
declare const Module: any;
`;

const INDENT = '  ';

// ---------------------------------------------------------------------------
// Helper: format a TypeScript parameter list from Arg[]
// ---------------------------------------------------------------------------

function formatTsParams(args: Arg[]): string {
  return args.map((a) => `${a.name}: ${tsTypeForArg(a)}`).join(', ');
}

// ---------------------------------------------------------------------------
// Helper: format a TypeScript return type annotation
// ---------------------------------------------------------------------------

function formatTsReturn(method: MethodDef, overload?: MethodOverload): string {
  const retType = getReturnType(method, overload);
  return cppToTsType(retType);
}

// ---------------------------------------------------------------------------
// Enum emission
// ---------------------------------------------------------------------------

function emitEnum(enumName: string, enumDef: EnumDef): string {
  const lines: string[] = [];

  // Type alias so enum values can be used as a type annotation
  lines.push(`export type ${enumName} = number;`);

  // Runtime object with getters that read from the WASM Module
  lines.push(`export const ${enumName} = {`);
  for (const value of enumDef.values) {
    lines.push(`  get ${value}(): number { return Module.${enumName}.${value}.value; },`);
  }
  lines.push(`};`);

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Constructor emission
// ---------------------------------------------------------------------------

/**
 * Emit TypeScript overload signatures for constructors.
 * Only emitted when there are multiple constructors.
 */
function emitConstructorOverloadSignatures(
  className: string,
  constructors: ConstructorDef[],
): string[] {
  if (constructors.length <= 1) return [];

  const lines: string[] = [];
  for (const ctor of constructors) {
    const params = formatTsParams(ctor.args);
    lines.push(`${INDENT}constructor(${params});`);
  }
  return lines;
}

/**
 * Emit the constructor implementation body with argument dispatch.
 */
function emitConstructorImpl(
  className: string,
  constructors: ConstructorDef[],
): string[] {
  const lines: string[] = [];

  if (constructors.length === 0) {
    // No constructors defined -- provide a default
    lines.push(`${INDENT}constructor() {`);
    lines.push(`${INDENT}${INDENT}this._handle = new Module.${className}();`);
    lines.push(`${INDENT}}`);
    return lines;
  }

  if (constructors.length === 1) {
    const ctor = constructors[0];
    const params = formatTsParams(ctor.args);
    lines.push(`${INDENT}constructor(${params}) {`);
    lines.push(...emitConstructorBody(className, ctor, `${INDENT}${INDENT}`));
    lines.push(`${INDENT}}`);
    return lines;
  }

  // Multiple constructors: variadic implementation with runtime dispatch
  lines.push(`${INDENT}constructor(...args: any[]) {`);

  for (let i = 0; i < constructors.length; i++) {
    const ctor = constructors[i];
    const check = generateInstanceofCheck(ctor.args, 'args');
    const keyword = i === 0 ? 'if' : '} else if';
    lines.push(`${INDENT}${INDENT}${keyword} (${check}) {`);
    lines.push(...emitConstructorBody(className, ctor, `${INDENT}${INDENT}${INDENT}`));
  }

  lines.push(`${INDENT}${INDENT}} else {`);
  lines.push(`${INDENT}${INDENT}${INDENT}throw new Error('Invalid arguments for ${className} constructor');`);
  lines.push(`${INDENT}${INDENT}}`);
  lines.push(`${INDENT}}`);

  return lines;
}

/**
 * Emit the body of a single constructor branch.
 */
function emitConstructorBody(
  className: string,
  ctor: ConstructorDef,
  indent: string,
): string[] {
  const lines: string[] = [];

  // Build the argument list, unwrapping OCCT class handles
  const argExprs = ctor.args.map((arg, i) => {
    if (isOcctClass(arg.type)) {
      return `args[${i}]._handle`;
    }
    return `args[${i}]`;
  });
  const argsStr = argExprs.join(', ');

  if (ctor.factory) {
    // Factory constructor: call static method on Module class
    lines.push(`${indent}this._handle = Module.${className}.${ctor.factory}(${argsStr});`);
  } else {
    lines.push(`${indent}this._handle = new Module.${className}(${argsStr});`);
  }

  return lines;
}

// ---------------------------------------------------------------------------
// Helper: emit body for a non-overloaded method using named parameters
// ---------------------------------------------------------------------------

function emitSimpleMethodBody(
  className: string,
  methodName: string,
  method: MethodDef,
  overload: MethodOverload,
  indent: string,
): string[] {
  const lines: string[] = [];
  const isStatic = overload.static ?? method.static ?? false;
  const returnType = getReturnType(method, overload);
  const tsReturn = cppToTsType(returnType);
  const returnsVoid = returnType === 'void';
  const returnsOcctClass = isOcctClass(returnType) && !isOcctEnum(returnType);

  // Build arg expressions using named parameters (not args[i])
  let argExprs: string[];
  if (method.output_args) {
    argExprs = overload.args.slice(1).map(arg =>
      (isOcctClass(arg.type) && !isOcctEnum(arg.type)) ? `${arg.name}._handle` : arg.name
    );
  } else {
    argExprs = overload.args.map(arg =>
      (isOcctClass(arg.type) && !isOcctEnum(arg.type)) ? `${arg.name}._handle` : arg.name
    );
  }
  const argsStr = argExprs.join(', ');

  let callExpr: string;
  if (isStatic) {
    callExpr = `Module.${className}.${methodName}(${argsStr})`;
  } else {
    callExpr = `this._handle.${methodName}(${argsStr})`;
  }

  if (returnsVoid) {
    lines.push(`${indent}${callExpr};`);
  } else if (returnsOcctClass) {
    lines.push(`${indent}const _result = ${callExpr};`);
    lines.push(`${indent}return ${tsReturn}._fromHandle(_result);`);
  } else {
    lines.push(`${indent}return ${callExpr};`);
  }

  return lines;
}

// ---------------------------------------------------------------------------
// Method emission
// ---------------------------------------------------------------------------

/**
 * Emit TypeScript overload signatures for an overloaded method.
 */
function emitMethodOverloadSignatures(
  methodName: string,
  method: MethodDef,
): string[] {
  if (!isOverloaded(method)) return [];

  const lines: string[] = [];
  const overloads = getOverloads(method);
  const isStatic = method.static ?? false;
  const prefix = isStatic ? 'static ' : '';

  for (const overload of overloads) {
    const isOverloadStatic = overload.static ?? isStatic;
    const staticPrefix = isOverloadStatic ? 'static ' : '';
    const retType = formatTsReturn(method, overload);

    if (method.output_args) {
      // output_args methods take no visible params in the TS signature
      lines.push(`${INDENT}${staticPrefix}${methodName}(): ${retType};`);
    } else {
      const params = formatTsParams(overload.args);
      lines.push(`${INDENT}${staticPrefix}${methodName}(${params}): ${retType};`);
    }
  }

  return lines;
}

/**
 * Emit a complete method (signatures + implementation) for a class.
 */
function emitMethod(
  className: string,
  methodName: string,
  method: MethodDef,
): string[] {
  const lines: string[] = [];
  const overloads = getOverloads(method);
  const overloaded = isOverloaded(method);
  const isStatic = method.static ?? false;
  const staticPrefix = isStatic ? 'static ' : '';

  // -- Overload signatures (only for truly overloaded methods) --
  if (overloaded) {
    lines.push(...emitMethodOverloadSignatures(methodName, method));
  }

  // -- Implementation signature --
  if (overloaded) {
    // Variadic implementation - use 'any' return type for compatibility with all overloads
    lines.push(`${INDENT}${staticPrefix}${methodName}(...args: any[]): any {`);
    lines.push(generateOverloadDispatch(className, methodName, method, `${INDENT}${INDENT}`));
    lines.push(`${INDENT}}`);
  } else {
    // Single method: direct implementation
    const overload = overloads[0];
    const retType = formatTsReturn(method, overload);
    const isMethodStatic = overload.static ?? isStatic;
    const prefix = isMethodStatic ? 'static ' : '';

    if (method.output_args) {
      // output_args: no params in TS, embind handles it
      lines.push(`${INDENT}${prefix}${methodName}(): ${retType} {`);
      lines.push(...emitSimpleMethodBody(className, methodName, method, overload, `${INDENT}${INDENT}`));
      lines.push(`${INDENT}}`);
    } else {
      const params = formatTsParams(overload.args);
      lines.push(`${INDENT}${prefix}${methodName}(${params}): ${retType} {`);
      lines.push(...emitSimpleMethodBody(className, methodName, method, overload, `${INDENT}${INDENT}`));
      lines.push(`${INDENT}}`);
    }
  }

  return lines;
}

// ---------------------------------------------------------------------------
// Class emission
// ---------------------------------------------------------------------------

function emitClass(className: string, classDef: ClassDef): string {
  const lines: string[] = [];

  lines.push(`export class ${className} {`);

  // _handle property
  lines.push(`${INDENT}/** @internal */`);
  lines.push(`${INDENT}_handle: any;`);
  lines.push('');

  // _fromHandle static factory
  lines.push(`${INDENT}/** @internal - construct from raw embind handle */`);
  lines.push(`${INDENT}static _fromHandle(h: any): ${className} {`);
  lines.push(`${INDENT}${INDENT}const obj = Object.create(${className}.prototype);`);
  lines.push(`${INDENT}${INDENT}obj._handle = h;`);
  lines.push(`${INDENT}${INDENT}return obj;`);
  lines.push(`${INDENT}}`);
  lines.push('');

  // Constructor overload signatures + implementation
  const ctorSignatures = emitConstructorOverloadSignatures(className, classDef.constructors);
  if (ctorSignatures.length > 0) {
    lines.push(...ctorSignatures);
  }
  lines.push(...emitConstructorImpl(className, classDef.constructors));
  lines.push('');

  // Methods (sorted for deterministic output)
  const methodNames = Object.keys(classDef.methods).sort();
  for (const methodName of methodNames) {
    if (classDef.skip?.includes(methodName)) continue;
    lines.push(...emitMethod(className, methodName, classDef.methods[methodName]));
    lines.push('');
  }

  // delete() method
  lines.push(`${INDENT}delete(): void {`);
  lines.push(`${INDENT}${INDENT}this._handle.delete();`);
  lines.push(`${INDENT}}`);

  lines.push('}');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Main export
// ---------------------------------------------------------------------------

/**
 * Generate a complete TypeScript file containing wrapper classes and enum
 * re-exports for a single OCCT module.
 */
export function emitTypeScriptWrappers(config: ModuleConfig): string {
  const sections: string[] = [];

  // File header with Module declaration
  sections.push(FILE_HEADER);

  // Enums (sorted for deterministic output)
  const enumNames = Object.keys(config.enums).sort();
  for (const enumName of enumNames) {
    sections.push(emitEnum(enumName, config.enums[enumName]));
  }

  // Classes (sorted for deterministic output)
  const classNames = Object.keys(config.classes).sort();
  for (const className of classNames) {
    sections.push(emitClass(className, config.classes[className]));
  }

  return sections.join('\n\n') + '\n';
}
